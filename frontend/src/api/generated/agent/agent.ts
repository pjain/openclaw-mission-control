/**
 * Generated by orval v8.3.0 üç∫
 * Do not edit manually.
 * Mission Control API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AgentCreate,
  AgentHealthStatusResponse,
  AgentNudge,
  AgentRead,
  ApprovalCreate,
  ApprovalRead,
  BoardMemoryCreate,
  BoardMemoryRead,
  BoardOnboardingAgentComplete,
  BoardOnboardingAgentQuestion,
  BoardOnboardingRead,
  BoardRead,
  GatewayLeadBroadcastRequest,
  GatewayLeadBroadcastResponse,
  GatewayLeadMessageRequest,
  GatewayLeadMessageResponse,
  GatewayMainAskUserRequest,
  GatewayMainAskUserResponse,
  HTTPValidationError,
  LLMErrorResponse,
  LimitOffsetPageTypeVarCustomizedAgentRead,
  LimitOffsetPageTypeVarCustomizedApprovalRead,
  LimitOffsetPageTypeVarCustomizedBoardMemoryRead,
  LimitOffsetPageTypeVarCustomizedBoardRead,
  LimitOffsetPageTypeVarCustomizedTaskCommentRead,
  LimitOffsetPageTypeVarCustomizedTaskRead,
  ListAgentsApiV1AgentAgentsGetParams,
  ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetParams,
  ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetParams,
  ListBoardsApiV1AgentBoardsGetParams,
  ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetParams,
  ListTasksApiV1AgentBoardsBoardIdTasksGetParams,
  OkResponse,
  SoulUpdateRequest,
  TagRef,
  TaskCommentCreate,
  TaskCommentRead,
  TaskCreate,
  TaskRead,
  TaskUpdate,
} from ".././model";

import { customFetch } from "../../mutator";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Token-authenticated liveness probe for agent API clients.

Use this endpoint when the caller needs to verify both service availability and agent-token validity in one request.
 * @summary Agent Auth Health Check
 */
export type agentHealthzApiV1AgentHealthzGetResponse200 = {
  data: AgentHealthStatusResponse;
  status: 200;
};

export type agentHealthzApiV1AgentHealthzGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type agentHealthzApiV1AgentHealthzGetResponseSuccess =
  agentHealthzApiV1AgentHealthzGetResponse200 & {
    headers: Headers;
  };
export type agentHealthzApiV1AgentHealthzGetResponseError =
  agentHealthzApiV1AgentHealthzGetResponse422 & {
    headers: Headers;
  };

export type agentHealthzApiV1AgentHealthzGetResponse =
  | agentHealthzApiV1AgentHealthzGetResponseSuccess
  | agentHealthzApiV1AgentHealthzGetResponseError;

export const getAgentHealthzApiV1AgentHealthzGetUrl = () => {
  return `/api/v1/agent/healthz`;
};

export const agentHealthzApiV1AgentHealthzGet = async (
  options?: RequestInit,
): Promise<agentHealthzApiV1AgentHealthzGetResponse> => {
  return customFetch<agentHealthzApiV1AgentHealthzGetResponse>(
    getAgentHealthzApiV1AgentHealthzGetUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getAgentHealthzApiV1AgentHealthzGetQueryKey = () => {
  return [`/api/v1/agent/healthz`] as const;
};

export const getAgentHealthzApiV1AgentHealthzGetQueryOptions = <
  TData = Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
  TError = HTTPValidationError,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAgentHealthzApiV1AgentHealthzGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>
  > = ({ signal }) =>
    agentHealthzApiV1AgentHealthzGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AgentHealthzApiV1AgentHealthzGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>
>;
export type AgentHealthzApiV1AgentHealthzGetQueryError = HTTPValidationError;

export function useAgentHealthzApiV1AgentHealthzGet<
  TData = Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
  TError = HTTPValidationError,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
          TError,
          Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAgentHealthzApiV1AgentHealthzGet<
  TData = Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
  TError = HTTPValidationError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
          TError,
          Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAgentHealthzApiV1AgentHealthzGet<
  TData = Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
  TError = HTTPValidationError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Agent Auth Health Check
 */

export function useAgentHealthzApiV1AgentHealthzGet<
  TData = Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
  TError = HTTPValidationError,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof agentHealthzApiV1AgentHealthzGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAgentHealthzApiV1AgentHealthzGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Return boards the authenticated agent can access.

Use this as a discovery step before board-scoped operations.
 * @summary List boards visible to the caller
 */
export type listBoardsApiV1AgentBoardsGetResponse200 = {
  data: LimitOffsetPageTypeVarCustomizedBoardRead;
  status: 200;
};

export type listBoardsApiV1AgentBoardsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type listBoardsApiV1AgentBoardsGetResponseSuccess =
  listBoardsApiV1AgentBoardsGetResponse200 & {
    headers: Headers;
  };
export type listBoardsApiV1AgentBoardsGetResponseError =
  listBoardsApiV1AgentBoardsGetResponse422 & {
    headers: Headers;
  };

export type listBoardsApiV1AgentBoardsGetResponse =
  | listBoardsApiV1AgentBoardsGetResponseSuccess
  | listBoardsApiV1AgentBoardsGetResponseError;

export const getListBoardsApiV1AgentBoardsGetUrl = (
  params?: ListBoardsApiV1AgentBoardsGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/agent/boards?${stringifiedParams}`
    : `/api/v1/agent/boards`;
};

export const listBoardsApiV1AgentBoardsGet = async (
  params?: ListBoardsApiV1AgentBoardsGetParams,
  options?: RequestInit,
): Promise<listBoardsApiV1AgentBoardsGetResponse> => {
  return customFetch<listBoardsApiV1AgentBoardsGetResponse>(
    getListBoardsApiV1AgentBoardsGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getListBoardsApiV1AgentBoardsGetQueryKey = (
  params?: ListBoardsApiV1AgentBoardsGetParams,
) => {
  return [`/api/v1/agent/boards`, ...(params ? [params] : [])] as const;
};

export const getListBoardsApiV1AgentBoardsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListBoardsApiV1AgentBoardsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListBoardsApiV1AgentBoardsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>
  > = ({ signal }) =>
    listBoardsApiV1AgentBoardsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListBoardsApiV1AgentBoardsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>
>;
export type ListBoardsApiV1AgentBoardsGetQueryError = HTTPValidationError;

export function useListBoardsApiV1AgentBoardsGet<
  TData = Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | ListBoardsApiV1AgentBoardsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
          TError,
          Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListBoardsApiV1AgentBoardsGet<
  TData = Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListBoardsApiV1AgentBoardsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
          TError,
          Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListBoardsApiV1AgentBoardsGet<
  TData = Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListBoardsApiV1AgentBoardsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List boards visible to the caller
 */

export function useListBoardsApiV1AgentBoardsGet<
  TData = Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListBoardsApiV1AgentBoardsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listBoardsApiV1AgentBoardsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListBoardsApiV1AgentBoardsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Read a single board entity if it is visible to the authenticated agent.

Use for targeted planning and routing decisions.
 * @summary Fetch a board by id
 */
export type getBoardApiV1AgentBoardsBoardIdGetResponse200 = {
  data: BoardRead;
  status: 200;
};

export type getBoardApiV1AgentBoardsBoardIdGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type getBoardApiV1AgentBoardsBoardIdGetResponseSuccess =
  getBoardApiV1AgentBoardsBoardIdGetResponse200 & {
    headers: Headers;
  };
export type getBoardApiV1AgentBoardsBoardIdGetResponseError =
  getBoardApiV1AgentBoardsBoardIdGetResponse422 & {
    headers: Headers;
  };

export type getBoardApiV1AgentBoardsBoardIdGetResponse =
  | getBoardApiV1AgentBoardsBoardIdGetResponseSuccess
  | getBoardApiV1AgentBoardsBoardIdGetResponseError;

export const getGetBoardApiV1AgentBoardsBoardIdGetUrl = (boardId: string) => {
  return `/api/v1/agent/boards/${boardId}`;
};

export const getBoardApiV1AgentBoardsBoardIdGet = async (
  boardId: string,
  options?: RequestInit,
): Promise<getBoardApiV1AgentBoardsBoardIdGetResponse> => {
  return customFetch<getBoardApiV1AgentBoardsBoardIdGetResponse>(
    getGetBoardApiV1AgentBoardsBoardIdGetUrl(boardId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetBoardApiV1AgentBoardsBoardIdGetQueryKey = (
  boardId: string,
) => {
  return [`/api/v1/agent/boards/${boardId}`] as const;
};

export const getGetBoardApiV1AgentBoardsBoardIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetBoardApiV1AgentBoardsBoardIdGetQueryKey(boardId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>
  > = ({ signal }) =>
    getBoardApiV1AgentBoardsBoardIdGet(boardId, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!boardId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBoardApiV1AgentBoardsBoardIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>
>;
export type GetBoardApiV1AgentBoardsBoardIdGetQueryError = HTTPValidationError;

export function useGetBoardApiV1AgentBoardsBoardIdGet<
  TData = Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBoardApiV1AgentBoardsBoardIdGet<
  TData = Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetBoardApiV1AgentBoardsBoardIdGet<
  TData = Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Fetch a board by id
 */

export function useGetBoardApiV1AgentBoardsBoardIdGet<
  TData = Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBoardApiV1AgentBoardsBoardIdGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetBoardApiV1AgentBoardsBoardIdGetQueryOptions(
    boardId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Return agents visible to the caller, optionally filtered by board.

Use when downstream routing or coordination needs recipient actors.
 * @summary List visible agents
 */
export type listAgentsApiV1AgentAgentsGetResponse200 = {
  data: LimitOffsetPageTypeVarCustomizedAgentRead;
  status: 200;
};

export type listAgentsApiV1AgentAgentsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type listAgentsApiV1AgentAgentsGetResponseSuccess =
  listAgentsApiV1AgentAgentsGetResponse200 & {
    headers: Headers;
  };
export type listAgentsApiV1AgentAgentsGetResponseError =
  listAgentsApiV1AgentAgentsGetResponse422 & {
    headers: Headers;
  };

export type listAgentsApiV1AgentAgentsGetResponse =
  | listAgentsApiV1AgentAgentsGetResponseSuccess
  | listAgentsApiV1AgentAgentsGetResponseError;

export const getListAgentsApiV1AgentAgentsGetUrl = (
  params?: ListAgentsApiV1AgentAgentsGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/agent/agents?${stringifiedParams}`
    : `/api/v1/agent/agents`;
};

export const listAgentsApiV1AgentAgentsGet = async (
  params?: ListAgentsApiV1AgentAgentsGetParams,
  options?: RequestInit,
): Promise<listAgentsApiV1AgentAgentsGetResponse> => {
  return customFetch<listAgentsApiV1AgentAgentsGetResponse>(
    getListAgentsApiV1AgentAgentsGetUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getListAgentsApiV1AgentAgentsGetQueryKey = (
  params?: ListAgentsApiV1AgentAgentsGetParams,
) => {
  return [`/api/v1/agent/agents`, ...(params ? [params] : [])] as const;
};

export const getListAgentsApiV1AgentAgentsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListAgentsApiV1AgentAgentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListAgentsApiV1AgentAgentsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>
  > = ({ signal }) =>
    listAgentsApiV1AgentAgentsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListAgentsApiV1AgentAgentsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>
>;
export type ListAgentsApiV1AgentAgentsGetQueryError = HTTPValidationError;

export function useListAgentsApiV1AgentAgentsGet<
  TData = Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
  TError = HTTPValidationError,
>(
  params: undefined | ListAgentsApiV1AgentAgentsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
          TError,
          Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListAgentsApiV1AgentAgentsGet<
  TData = Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListAgentsApiV1AgentAgentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
          TError,
          Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListAgentsApiV1AgentAgentsGet<
  TData = Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListAgentsApiV1AgentAgentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List visible agents
 */

export function useListAgentsApiV1AgentAgentsGet<
  TData = Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
  TError = HTTPValidationError,
>(
  params?: ListAgentsApiV1AgentAgentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listAgentsApiV1AgentAgentsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListAgentsApiV1AgentAgentsGetQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Register a new board agent and attach it to the lead's board.

The target board is derived from the caller identity and cannot be changed in payload.
 * @summary Create a board agent as lead
 */
export type agentLeadCreateAgentResponse200 = {
  data: AgentRead;
  status: 200;
};

export type agentLeadCreateAgentResponse403 = {
  data: LLMErrorResponse;
  status: 403;
};

export type agentLeadCreateAgentResponse409 = {
  data: LLMErrorResponse;
  status: 409;
};

export type agentLeadCreateAgentResponse422 = {
  data: LLMErrorResponse;
  status: 422;
};

export type agentLeadCreateAgentResponseSuccess =
  agentLeadCreateAgentResponse200 & {
    headers: Headers;
  };
export type agentLeadCreateAgentResponseError = (
  | agentLeadCreateAgentResponse403
  | agentLeadCreateAgentResponse409
  | agentLeadCreateAgentResponse422
) & {
  headers: Headers;
};

export type agentLeadCreateAgentResponse =
  | agentLeadCreateAgentResponseSuccess
  | agentLeadCreateAgentResponseError;

export const getAgentLeadCreateAgentUrl = () => {
  return `/api/v1/agent/agents`;
};

export const agentLeadCreateAgent = async (
  agentCreate: AgentCreate,
  options?: RequestInit,
): Promise<agentLeadCreateAgentResponse> => {
  return customFetch<agentLeadCreateAgentResponse>(
    getAgentLeadCreateAgentUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(agentCreate),
    },
  );
};

export const getAgentLeadCreateAgentMutationOptions = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentLeadCreateAgent>>,
    TError,
    { data: AgentCreate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentLeadCreateAgent>>,
  TError,
  { data: AgentCreate },
  TContext
> => {
  const mutationKey = ["agentLeadCreateAgent"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentLeadCreateAgent>>,
    { data: AgentCreate }
  > = (props) => {
    const { data } = props ?? {};

    return agentLeadCreateAgent(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AgentLeadCreateAgentMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentLeadCreateAgent>>
>;
export type AgentLeadCreateAgentMutationBody = AgentCreate;
export type AgentLeadCreateAgentMutationError = LLMErrorResponse;

/**
 * @summary Create a board agent as lead
 */
export const useAgentLeadCreateAgent = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentLeadCreateAgent>>,
      TError,
      { data: AgentCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof agentLeadCreateAgent>>,
  TError,
  { data: AgentCreate },
  TContext
> => {
  return useMutation(
    getAgentLeadCreateAgentMutationOptions(options),
    queryClient,
  );
};
/**
 * List tasks on a board with status/assignment filters.

Common patterns:
- worker: fetch assigned inbox/in-progress tasks
- lead: fetch unassigned inbox tasks for delegation
 * @summary List Tasks
 */
export type listTasksApiV1AgentBoardsBoardIdTasksGetResponse200 = {
  data: LimitOffsetPageTypeVarCustomizedTaskRead;
  status: 200;
};

export type listTasksApiV1AgentBoardsBoardIdTasksGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type listTasksApiV1AgentBoardsBoardIdTasksGetResponseSuccess =
  listTasksApiV1AgentBoardsBoardIdTasksGetResponse200 & {
    headers: Headers;
  };
export type listTasksApiV1AgentBoardsBoardIdTasksGetResponseError =
  listTasksApiV1AgentBoardsBoardIdTasksGetResponse422 & {
    headers: Headers;
  };

export type listTasksApiV1AgentBoardsBoardIdTasksGetResponse =
  | listTasksApiV1AgentBoardsBoardIdTasksGetResponseSuccess
  | listTasksApiV1AgentBoardsBoardIdTasksGetResponseError;

export const getListTasksApiV1AgentBoardsBoardIdTasksGetUrl = (
  boardId: string,
  params?: ListTasksApiV1AgentBoardsBoardIdTasksGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/agent/boards/${boardId}/tasks?${stringifiedParams}`
    : `/api/v1/agent/boards/${boardId}/tasks`;
};

export const listTasksApiV1AgentBoardsBoardIdTasksGet = async (
  boardId: string,
  params?: ListTasksApiV1AgentBoardsBoardIdTasksGetParams,
  options?: RequestInit,
): Promise<listTasksApiV1AgentBoardsBoardIdTasksGetResponse> => {
  return customFetch<listTasksApiV1AgentBoardsBoardIdTasksGetResponse>(
    getListTasksApiV1AgentBoardsBoardIdTasksGetUrl(boardId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getListTasksApiV1AgentBoardsBoardIdTasksGetQueryKey = (
  boardId: string,
  params?: ListTasksApiV1AgentBoardsBoardIdTasksGetParams,
) => {
  return [
    `/api/v1/agent/boards/${boardId}/tasks`,
    ...(params ? [params] : []),
  ] as const;
};

export const getListTasksApiV1AgentBoardsBoardIdTasksGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListTasksApiV1AgentBoardsBoardIdTasksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListTasksApiV1AgentBoardsBoardIdTasksGetQueryKey(boardId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>
  > = ({ signal }) =>
    listTasksApiV1AgentBoardsBoardIdTasksGet(boardId, params, {
      signal,
      ...requestOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!boardId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListTasksApiV1AgentBoardsBoardIdTasksGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>
>;
export type ListTasksApiV1AgentBoardsBoardIdTasksGetQueryError =
  HTTPValidationError;

export function useListTasksApiV1AgentBoardsBoardIdTasksGet<
  TData = Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  params: undefined | ListTasksApiV1AgentBoardsBoardIdTasksGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
          TError,
          Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListTasksApiV1AgentBoardsBoardIdTasksGet<
  TData = Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListTasksApiV1AgentBoardsBoardIdTasksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
          TError,
          Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListTasksApiV1AgentBoardsBoardIdTasksGet<
  TData = Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListTasksApiV1AgentBoardsBoardIdTasksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Tasks
 */

export function useListTasksApiV1AgentBoardsBoardIdTasksGet<
  TData = Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListTasksApiV1AgentBoardsBoardIdTasksGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listTasksApiV1AgentBoardsBoardIdTasksGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListTasksApiV1AgentBoardsBoardIdTasksGetQueryOptions(
    boardId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create a new task on a board and persist lead metadata.

Use when a lead needs to introduce new work, create dependencies, or directly assign ownership.
Do not use for task updates or comments; those are separate endpoints.
 * @summary Create and assign a new board task as a lead agent
 */
export type agentLeadCreateTaskResponse200 = {
  data: TaskRead;
  status: 200;
};

export type agentLeadCreateTaskResponse403 = {
  data: LLMErrorResponse;
  status: 403;
};

export type agentLeadCreateTaskResponse404 = {
  data: LLMErrorResponse;
  status: 404;
};

export type agentLeadCreateTaskResponse409 = {
  data: LLMErrorResponse;
  status: 409;
};

export type agentLeadCreateTaskResponse422 = {
  data: LLMErrorResponse;
  status: 422;
};

export type agentLeadCreateTaskResponseSuccess =
  agentLeadCreateTaskResponse200 & {
    headers: Headers;
  };
export type agentLeadCreateTaskResponseError = (
  | agentLeadCreateTaskResponse403
  | agentLeadCreateTaskResponse404
  | agentLeadCreateTaskResponse409
  | agentLeadCreateTaskResponse422
) & {
  headers: Headers;
};

export type agentLeadCreateTaskResponse =
  | agentLeadCreateTaskResponseSuccess
  | agentLeadCreateTaskResponseError;

export const getAgentLeadCreateTaskUrl = (boardId: string) => {
  return `/api/v1/agent/boards/${boardId}/tasks`;
};

export const agentLeadCreateTask = async (
  boardId: string,
  taskCreate: TaskCreate,
  options?: RequestInit,
): Promise<agentLeadCreateTaskResponse> => {
  return customFetch<agentLeadCreateTaskResponse>(
    getAgentLeadCreateTaskUrl(boardId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(taskCreate),
    },
  );
};

export const getAgentLeadCreateTaskMutationOptions = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentLeadCreateTask>>,
    TError,
    { boardId: string; data: TaskCreate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentLeadCreateTask>>,
  TError,
  { boardId: string; data: TaskCreate },
  TContext
> => {
  const mutationKey = ["agentLeadCreateTask"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentLeadCreateTask>>,
    { boardId: string; data: TaskCreate }
  > = (props) => {
    const { boardId, data } = props ?? {};

    return agentLeadCreateTask(boardId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AgentLeadCreateTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentLeadCreateTask>>
>;
export type AgentLeadCreateTaskMutationBody = TaskCreate;
export type AgentLeadCreateTaskMutationError = LLMErrorResponse;

/**
 * @summary Create and assign a new board task as a lead agent
 */
export const useAgentLeadCreateTask = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentLeadCreateTask>>,
      TError,
      { boardId: string; data: TaskCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof agentLeadCreateTask>>,
  TError,
  { boardId: string; data: TaskCreate },
  TContext
> => {
  return useMutation(
    getAgentLeadCreateTaskMutationOptions(options),
    queryClient,
  );
};
/**
 * List available tags for the board's organization.

Use returned ids in task create/update payloads (`tag_ids`).
 * @summary List Tags
 */
export type listTagsApiV1AgentBoardsBoardIdTagsGetResponse200 = {
  data: TagRef[];
  status: 200;
};

export type listTagsApiV1AgentBoardsBoardIdTagsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type listTagsApiV1AgentBoardsBoardIdTagsGetResponseSuccess =
  listTagsApiV1AgentBoardsBoardIdTagsGetResponse200 & {
    headers: Headers;
  };
export type listTagsApiV1AgentBoardsBoardIdTagsGetResponseError =
  listTagsApiV1AgentBoardsBoardIdTagsGetResponse422 & {
    headers: Headers;
  };

export type listTagsApiV1AgentBoardsBoardIdTagsGetResponse =
  | listTagsApiV1AgentBoardsBoardIdTagsGetResponseSuccess
  | listTagsApiV1AgentBoardsBoardIdTagsGetResponseError;

export const getListTagsApiV1AgentBoardsBoardIdTagsGetUrl = (
  boardId: string,
) => {
  return `/api/v1/agent/boards/${boardId}/tags`;
};

export const listTagsApiV1AgentBoardsBoardIdTagsGet = async (
  boardId: string,
  options?: RequestInit,
): Promise<listTagsApiV1AgentBoardsBoardIdTagsGetResponse> => {
  return customFetch<listTagsApiV1AgentBoardsBoardIdTagsGetResponse>(
    getListTagsApiV1AgentBoardsBoardIdTagsGetUrl(boardId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getListTagsApiV1AgentBoardsBoardIdTagsGetQueryKey = (
  boardId: string,
) => {
  return [`/api/v1/agent/boards/${boardId}/tags`] as const;
};

export const getListTagsApiV1AgentBoardsBoardIdTagsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListTagsApiV1AgentBoardsBoardIdTagsGetQueryKey(boardId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>
  > = ({ signal }) =>
    listTagsApiV1AgentBoardsBoardIdTagsGet(boardId, {
      signal,
      ...requestOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!boardId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListTagsApiV1AgentBoardsBoardIdTagsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>
>;
export type ListTagsApiV1AgentBoardsBoardIdTagsGetQueryError =
  HTTPValidationError;

export function useListTagsApiV1AgentBoardsBoardIdTagsGet<
  TData = Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
          TError,
          Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListTagsApiV1AgentBoardsBoardIdTagsGet<
  TData = Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
          TError,
          Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListTagsApiV1AgentBoardsBoardIdTagsGet<
  TData = Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Tags
 */

export function useListTagsApiV1AgentBoardsBoardIdTagsGet<
  TData = Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
  TError = HTTPValidationError,
>(
  boardId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listTagsApiV1AgentBoardsBoardIdTagsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListTagsApiV1AgentBoardsBoardIdTagsGetQueryOptions(
    boardId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Update a task after board-level authorization checks.

Supports status, assignment, dependencies, and optional inline comment.
 * @summary Update Task
 */
export type updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponse200 = {
  data: TaskRead;
  status: 200;
};

export type updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponseSuccess =
  updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponse200 & {
    headers: Headers;
  };
export type updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponseError =
  updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponse422 & {
    headers: Headers;
  };

export type updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponse =
  | updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponseSuccess
  | updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponseError;

export const getUpdateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchUrl = (
  boardId: string,
  taskId: string,
) => {
  return `/api/v1/agent/boards/${boardId}/tasks/${taskId}`;
};

export const updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatch = async (
  boardId: string,
  taskId: string,
  taskUpdate: TaskUpdate,
  options?: RequestInit,
): Promise<updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponse> => {
  return customFetch<updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchResponse>(
    getUpdateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchUrl(boardId, taskId),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(taskUpdate),
    },
  );
};

export const getUpdateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatch>
      >,
      TError,
      { boardId: string; taskId: string; data: TaskUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatch>
    >,
    TError,
    { boardId: string; taskId: string; data: TaskUpdate },
    TContext
  > => {
    const mutationKey = ["updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatch"];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatch>
      >,
      { boardId: string; taskId: string; data: TaskUpdate }
    > = (props) => {
      const { boardId, taskId, data } = props ?? {};

      return updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatch(
        boardId,
        taskId,
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatch>
    >
  >;
export type UpdateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchMutationBody =
  TaskUpdate;
export type UpdateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchMutationError =
  HTTPValidationError;

/**
 * @summary Update Task
 */
export const useUpdateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatch = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatch>
      >,
      TError,
      { boardId: string; taskId: string; data: TaskUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatch>>,
  TError,
  { boardId: string; taskId: string; data: TaskUpdate },
  TContext
> => {
  return useMutation(
    getUpdateTaskApiV1AgentBoardsBoardIdTasksTaskIdPatchMutationOptions(
      options,
    ),
    queryClient,
  );
};
/**
 * Delete a board task and related records.

This action is restricted to board lead agents.
 * @summary Delete a task as board lead
 */
export type deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponse200 = {
  data: OkResponse;
  status: 200;
};

export type deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponseSuccess =
  deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponse200 & {
    headers: Headers;
  };
export type deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponseError =
  deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponse422 & {
    headers: Headers;
  };

export type deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponse =
  | deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponseSuccess
  | deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponseError;

export const getDeleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteUrl = (
  boardId: string,
  taskId: string,
) => {
  return `/api/v1/agent/boards/${boardId}/tasks/${taskId}`;
};

export const deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDelete = async (
  boardId: string,
  taskId: string,
  options?: RequestInit,
): Promise<deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponse> => {
  return customFetch<deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteResponse>(
    getDeleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteUrl(boardId, taskId),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getDeleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDelete>
      >,
      TError,
      { boardId: string; taskId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDelete>
    >,
    TError,
    { boardId: string; taskId: string },
    TContext
  > => {
    const mutationKey = ["deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDelete"];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDelete>
      >,
      { boardId: string; taskId: string }
    > = (props) => {
      const { boardId, taskId } = props ?? {};

      return deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDelete(
        boardId,
        taskId,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDelete>
    >
  >;

export type DeleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteMutationError =
  HTTPValidationError;

/**
 * @summary Delete a task as board lead
 */
export const useDeleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDelete = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDelete>
      >,
      TError,
      { boardId: string; taskId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof deleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDelete>
  >,
  TError,
  { boardId: string; taskId: string },
  TContext
> => {
  return useMutation(
    getDeleteTaskApiV1AgentBoardsBoardIdTasksTaskIdDeleteMutationOptions(
      options,
    ),
    queryClient,
  );
};
/**
 * List task comments visible to the authenticated agent.

Read this before posting updates to avoid duplicate or low-value comments.
 * @summary List Task Comments
 */
export type listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponse200 =
  {
    data: LimitOffsetPageTypeVarCustomizedTaskCommentRead;
    status: 200;
  };

export type listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponseSuccess =
  listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponse200 & {
    headers: Headers;
  };
export type listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponseError =
  listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponse422 & {
    headers: Headers;
  };

export type listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponse =

    | listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponseSuccess
    | listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponseError;

export const getListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetUrl =
  (
    boardId: string,
    taskId: string,
    params?: ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetParams,
  ) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(
          key,
          value === null ? "null" : value.toString(),
        );
      }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
      ? `/api/v1/agent/boards/${boardId}/tasks/${taskId}/comments?${stringifiedParams}`
      : `/api/v1/agent/boards/${boardId}/tasks/${taskId}/comments`;
  };

export const listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet =
  async (
    boardId: string,
    taskId: string,
    params?: ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetParams,
    options?: RequestInit,
  ): Promise<listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponse> => {
    return customFetch<listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetResponse>(
      getListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetUrl(
        boardId,
        taskId,
        params,
      ),
      {
        ...options,
        method: "GET",
      },
    );
  };

export const getListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetQueryKey =
  (
    boardId: string,
    taskId: string,
    params?: ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetParams,
  ) => {
    return [
      `/api/v1/agent/boards/${boardId}/tasks/${taskId}/comments`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
      >
    >,
    TError = HTTPValidationError,
  >(
    boardId: string,
    taskId: string,
    params?: ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
            >
          >,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customFetch>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetQueryKey(
        boardId,
        taskId,
        params,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
        >
      >
    > = ({ signal }) =>
      listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet(
        boardId,
        taskId,
        params,
        { signal, ...requestOptions },
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(boardId && taskId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
      >
    >
  >;
export type ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetQueryError =
  HTTPValidationError;

export function useListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet<
  TData = Awaited<
    ReturnType<
      typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
    >
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  taskId: string,
  params:
    | undefined
    | ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
            >
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet<
  TData = Awaited<
    ReturnType<
      typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
    >
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  taskId: string,
  params?: ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
            >
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet<
  TData = Awaited<
    ReturnType<
      typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
    >
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  taskId: string,
  params?: ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Task Comments
 */

export function useListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet<
  TData = Awaited<
    ReturnType<
      typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
    >
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  taskId: string,
  params?: ListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof listTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGet
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getListTaskCommentsApiV1AgentBoardsBoardIdTasksTaskIdCommentsGetQueryOptions(
      boardId,
      taskId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create a task comment as the authenticated agent.

This is the primary collaboration/log surface for task progress.
 * @summary Create Task Comment
 */
export type createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponse200 =
  {
    data: TaskCommentRead;
    status: 200;
  };

export type createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponseSuccess =
  createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponse200 & {
    headers: Headers;
  };
export type createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponseError =
  createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponse422 & {
    headers: Headers;
  };

export type createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponse =

    | createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponseSuccess
    | createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponseError;

export const getCreateTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostUrl =
  (boardId: string, taskId: string) => {
    return `/api/v1/agent/boards/${boardId}/tasks/${taskId}/comments`;
  };

export const createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPost =
  async (
    boardId: string,
    taskId: string,
    taskCommentCreate: TaskCommentCreate,
    options?: RequestInit,
  ): Promise<createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponse> => {
    return customFetch<createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostResponse>(
      getCreateTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostUrl(
        boardId,
        taskId,
      ),
      {
        ...options,
        method: "POST",
        headers: { "Content-Type": "application/json", ...options?.headers },
        body: JSON.stringify(taskCommentCreate),
      },
    );
  };

export const getCreateTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPost
        >
      >,
      TError,
      { boardId: string; taskId: string; data: TaskCommentCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<
        typeof createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPost
      >
    >,
    TError,
    { boardId: string; taskId: string; data: TaskCommentCreate },
    TContext
  > => {
    const mutationKey = [
      "createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPost",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPost
        >
      >,
      { boardId: string; taskId: string; data: TaskCommentCreate }
    > = (props) => {
      const { boardId, taskId, data } = props ?? {};

      return createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPost(
        boardId,
        taskId,
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPost
      >
    >
  >;
export type CreateTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostMutationBody =
  TaskCommentCreate;
export type CreateTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Task Comment
 */
export const useCreateTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPost =
  <TError = HTTPValidationError, TContext = unknown>(
    options?: {
      mutation?: UseMutationOptions<
        Awaited<
          ReturnType<
            typeof createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPost
          >
        >,
        TError,
        { boardId: string; taskId: string; data: TaskCommentCreate },
        TContext
      >;
      request?: SecondParameter<typeof customFetch>;
    },
    queryClient?: QueryClient,
  ): UseMutationResult<
    Awaited<
      ReturnType<
        typeof createTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPost
      >
    >,
    TError,
    { boardId: string; taskId: string; data: TaskCommentCreate },
    TContext
  > => {
    return useMutation(
      getCreateTaskCommentApiV1AgentBoardsBoardIdTasksTaskIdCommentsPostMutationOptions(
        options,
      ),
      queryClient,
    );
  };
/**
 * List board memory with optional chat filtering.

Use `is_chat=false` for durable context and `is_chat=true` for board chat.
 * @summary List Board Memory
 */
export type listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponse200 = {
  data: LimitOffsetPageTypeVarCustomizedBoardMemoryRead;
  status: 200;
};

export type listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponseSuccess =
  listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponse200 & {
    headers: Headers;
  };
export type listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponseError =
  listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponse422 & {
    headers: Headers;
  };

export type listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponse =
  | listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponseSuccess
  | listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponseError;

export const getListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetUrl = (
  boardId: string,
  params?: ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/agent/boards/${boardId}/memory?${stringifiedParams}`
    : `/api/v1/agent/boards/${boardId}/memory`;
};

export const listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet = async (
  boardId: string,
  params?: ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetParams,
  options?: RequestInit,
): Promise<listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponse> => {
  return customFetch<listBoardMemoryApiV1AgentBoardsBoardIdMemoryGetResponse>(
    getListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetUrl(boardId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetQueryKey = (
  boardId: string,
  params?: ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetParams,
) => {
  return [
    `/api/v1/agent/boards/${boardId}/memory`,
    ...(params ? [params] : []),
  ] as const;
};

export const getListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetQueryKey(boardId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>>
  > = ({ signal }) =>
    listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet(boardId, params, {
      signal,
      ...requestOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!boardId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>>
  >;
export type ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetQueryError =
  HTTPValidationError;

export function useListBoardMemoryApiV1AgentBoardsBoardIdMemoryGet<
  TData = Awaited<
    ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  params: undefined | ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListBoardMemoryApiV1AgentBoardsBoardIdMemoryGet<
  TData = Awaited<
    ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListBoardMemoryApiV1AgentBoardsBoardIdMemoryGet<
  TData = Awaited<
    ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Board Memory
 */

export function useListBoardMemoryApiV1AgentBoardsBoardIdMemoryGet<
  TData = Awaited<
    ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listBoardMemoryApiV1AgentBoardsBoardIdMemoryGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getListBoardMemoryApiV1AgentBoardsBoardIdMemoryGetQueryOptions(
      boardId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create a board memory entry.

Use tags to indicate purpose (e.g. `chat`, `decision`, `plan`, `handoff`).
 * @summary Create Board Memory
 */
export type createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponse200 = {
  data: BoardMemoryRead;
  status: 200;
};

export type createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponseSuccess =
  createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponse200 & {
    headers: Headers;
  };
export type createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponseError =
  createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponse422 & {
    headers: Headers;
  };

export type createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponse =
  | createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponseSuccess
  | createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponseError;

export const getCreateBoardMemoryApiV1AgentBoardsBoardIdMemoryPostUrl = (
  boardId: string,
) => {
  return `/api/v1/agent/boards/${boardId}/memory`;
};

export const createBoardMemoryApiV1AgentBoardsBoardIdMemoryPost = async (
  boardId: string,
  boardMemoryCreate: BoardMemoryCreate,
  options?: RequestInit,
): Promise<createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponse> => {
  return customFetch<createBoardMemoryApiV1AgentBoardsBoardIdMemoryPostResponse>(
    getCreateBoardMemoryApiV1AgentBoardsBoardIdMemoryPostUrl(boardId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(boardMemoryCreate),
    },
  );
};

export const getCreateBoardMemoryApiV1AgentBoardsBoardIdMemoryPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createBoardMemoryApiV1AgentBoardsBoardIdMemoryPost>
      >,
      TError,
      { boardId: string; data: BoardMemoryCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof createBoardMemoryApiV1AgentBoardsBoardIdMemoryPost>
    >,
    TError,
    { boardId: string; data: BoardMemoryCreate },
    TContext
  > => {
    const mutationKey = ["createBoardMemoryApiV1AgentBoardsBoardIdMemoryPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof createBoardMemoryApiV1AgentBoardsBoardIdMemoryPost>
      >,
      { boardId: string; data: BoardMemoryCreate }
    > = (props) => {
      const { boardId, data } = props ?? {};

      return createBoardMemoryApiV1AgentBoardsBoardIdMemoryPost(
        boardId,
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateBoardMemoryApiV1AgentBoardsBoardIdMemoryPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof createBoardMemoryApiV1AgentBoardsBoardIdMemoryPost>
    >
  >;
export type CreateBoardMemoryApiV1AgentBoardsBoardIdMemoryPostMutationBody =
  BoardMemoryCreate;
export type CreateBoardMemoryApiV1AgentBoardsBoardIdMemoryPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Board Memory
 */
export const useCreateBoardMemoryApiV1AgentBoardsBoardIdMemoryPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createBoardMemoryApiV1AgentBoardsBoardIdMemoryPost>
      >,
      TError,
      { boardId: string; data: BoardMemoryCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof createBoardMemoryApiV1AgentBoardsBoardIdMemoryPost>
  >,
  TError,
  { boardId: string; data: BoardMemoryCreate },
  TContext
> => {
  return useMutation(
    getCreateBoardMemoryApiV1AgentBoardsBoardIdMemoryPostMutationOptions(
      options,
    ),
    queryClient,
  );
};
/**
 * List approvals for a board.

Use status filtering to process pending approvals efficiently.
 * @summary List Approvals
 */
export type listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponse200 = {
  data: LimitOffsetPageTypeVarCustomizedApprovalRead;
  status: 200;
};

export type listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponseSuccess =
  listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponse200 & {
    headers: Headers;
  };
export type listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponseError =
  listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponse422 & {
    headers: Headers;
  };

export type listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponse =
  | listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponseSuccess
  | listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponseError;

export const getListApprovalsApiV1AgentBoardsBoardIdApprovalsGetUrl = (
  boardId: string,
  params?: ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/agent/boards/${boardId}/approvals?${stringifiedParams}`
    : `/api/v1/agent/boards/${boardId}/approvals`;
};

export const listApprovalsApiV1AgentBoardsBoardIdApprovalsGet = async (
  boardId: string,
  params?: ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetParams,
  options?: RequestInit,
): Promise<listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponse> => {
  return customFetch<listApprovalsApiV1AgentBoardsBoardIdApprovalsGetResponse>(
    getListApprovalsApiV1AgentBoardsBoardIdApprovalsGetUrl(boardId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getListApprovalsApiV1AgentBoardsBoardIdApprovalsGetQueryKey = (
  boardId: string,
  params?: ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetParams,
) => {
  return [
    `/api/v1/agent/boards/${boardId}/approvals`,
    ...(params ? [params] : []),
  ] as const;
};

export const getListApprovalsApiV1AgentBoardsBoardIdApprovalsGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListApprovalsApiV1AgentBoardsBoardIdApprovalsGetQueryKey(
      boardId,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>>
  > = ({ signal }) =>
    listApprovalsApiV1AgentBoardsBoardIdApprovalsGet(boardId, params, {
      signal,
      ...requestOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!boardId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<
      ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
    >,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>>
  >;
export type ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetQueryError =
  HTTPValidationError;

export function useListApprovalsApiV1AgentBoardsBoardIdApprovalsGet<
  TData = Awaited<
    ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  params: undefined | ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListApprovalsApiV1AgentBoardsBoardIdApprovalsGet<
  TData = Awaited<
    ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListApprovalsApiV1AgentBoardsBoardIdApprovalsGet<
  TData = Awaited<
    ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Approvals
 */

export function useListApprovalsApiV1AgentBoardsBoardIdApprovalsGet<
  TData = Awaited<
    ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  params?: ListApprovalsApiV1AgentBoardsBoardIdApprovalsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof listApprovalsApiV1AgentBoardsBoardIdApprovalsGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getListApprovalsApiV1AgentBoardsBoardIdApprovalsGetQueryOptions(
      boardId,
      params,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create an approval request for risky or low-confidence actions.

Include `task_id` or `task_ids` to scope the decision precisely.
 * @summary Create Approval
 */
export type createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponse200 = {
  data: ApprovalRead;
  status: 200;
};

export type createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponseSuccess =
  createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponse200 & {
    headers: Headers;
  };
export type createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponseError =
  createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponse422 & {
    headers: Headers;
  };

export type createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponse =
  | createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponseSuccess
  | createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponseError;

export const getCreateApprovalApiV1AgentBoardsBoardIdApprovalsPostUrl = (
  boardId: string,
) => {
  return `/api/v1/agent/boards/${boardId}/approvals`;
};

export const createApprovalApiV1AgentBoardsBoardIdApprovalsPost = async (
  boardId: string,
  approvalCreate: ApprovalCreate,
  options?: RequestInit,
): Promise<createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponse> => {
  return customFetch<createApprovalApiV1AgentBoardsBoardIdApprovalsPostResponse>(
    getCreateApprovalApiV1AgentBoardsBoardIdApprovalsPostUrl(boardId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(approvalCreate),
    },
  );
};

export const getCreateApprovalApiV1AgentBoardsBoardIdApprovalsPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createApprovalApiV1AgentBoardsBoardIdApprovalsPost>
      >,
      TError,
      { boardId: string; data: ApprovalCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof createApprovalApiV1AgentBoardsBoardIdApprovalsPost>
    >,
    TError,
    { boardId: string; data: ApprovalCreate },
    TContext
  > => {
    const mutationKey = ["createApprovalApiV1AgentBoardsBoardIdApprovalsPost"];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof createApprovalApiV1AgentBoardsBoardIdApprovalsPost>
      >,
      { boardId: string; data: ApprovalCreate }
    > = (props) => {
      const { boardId, data } = props ?? {};

      return createApprovalApiV1AgentBoardsBoardIdApprovalsPost(
        boardId,
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type CreateApprovalApiV1AgentBoardsBoardIdApprovalsPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof createApprovalApiV1AgentBoardsBoardIdApprovalsPost>
    >
  >;
export type CreateApprovalApiV1AgentBoardsBoardIdApprovalsPostMutationBody =
  ApprovalCreate;
export type CreateApprovalApiV1AgentBoardsBoardIdApprovalsPostMutationError =
  HTTPValidationError;

/**
 * @summary Create Approval
 */
export const useCreateApprovalApiV1AgentBoardsBoardIdApprovalsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof createApprovalApiV1AgentBoardsBoardIdApprovalsPost>
      >,
      TError,
      { boardId: string; data: ApprovalCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof createApprovalApiV1AgentBoardsBoardIdApprovalsPost>
  >,
  TError,
  { boardId: string; data: ApprovalCreate },
  TContext
> => {
  return useMutation(
    getCreateApprovalApiV1AgentBoardsBoardIdApprovalsPostMutationOptions(
      options,
    ),
    queryClient,
  );
};
/**
 * Apply board onboarding updates from an agent workflow.

Used during structured objective/success-metric intake loops.
 * @summary Update Onboarding
 */
export type updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponse200 = {
  data: BoardOnboardingRead;
  status: 200;
};

export type updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponseSuccess =
  updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponse200 & {
    headers: Headers;
  };
export type updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponseError =
  updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponse422 & {
    headers: Headers;
  };

export type updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponse =
  | updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponseSuccess
  | updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponseError;

export const getUpdateOnboardingApiV1AgentBoardsBoardIdOnboardingPostUrl = (
  boardId: string,
) => {
  return `/api/v1/agent/boards/${boardId}/onboarding`;
};

export const updateOnboardingApiV1AgentBoardsBoardIdOnboardingPost = async (
  boardId: string,
  boardOnboardingAgentCompleteBoardOnboardingAgentQuestion:
    | BoardOnboardingAgentComplete
    | BoardOnboardingAgentQuestion,
  options?: RequestInit,
): Promise<updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponse> => {
  return customFetch<updateOnboardingApiV1AgentBoardsBoardIdOnboardingPostResponse>(
    getUpdateOnboardingApiV1AgentBoardsBoardIdOnboardingPostUrl(boardId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(
        boardOnboardingAgentCompleteBoardOnboardingAgentQuestion,
      ),
    },
  );
};

export const getUpdateOnboardingApiV1AgentBoardsBoardIdOnboardingPostMutationOptions =
  <TError = HTTPValidationError, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateOnboardingApiV1AgentBoardsBoardIdOnboardingPost>
      >,
      TError,
      {
        boardId: string;
        data: BoardOnboardingAgentComplete | BoardOnboardingAgentQuestion;
      },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof updateOnboardingApiV1AgentBoardsBoardIdOnboardingPost>
    >,
    TError,
    {
      boardId: string;
      data: BoardOnboardingAgentComplete | BoardOnboardingAgentQuestion;
    },
    TContext
  > => {
    const mutationKey = [
      "updateOnboardingApiV1AgentBoardsBoardIdOnboardingPost",
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateOnboardingApiV1AgentBoardsBoardIdOnboardingPost>
      >,
      {
        boardId: string;
        data: BoardOnboardingAgentComplete | BoardOnboardingAgentQuestion;
      }
    > = (props) => {
      const { boardId, data } = props ?? {};

      return updateOnboardingApiV1AgentBoardsBoardIdOnboardingPost(
        boardId,
        data,
        requestOptions,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateOnboardingApiV1AgentBoardsBoardIdOnboardingPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof updateOnboardingApiV1AgentBoardsBoardIdOnboardingPost>
    >
  >;
export type UpdateOnboardingApiV1AgentBoardsBoardIdOnboardingPostMutationBody =
  | BoardOnboardingAgentComplete
  | BoardOnboardingAgentQuestion;
export type UpdateOnboardingApiV1AgentBoardsBoardIdOnboardingPostMutationError =
  HTTPValidationError;

/**
 * @summary Update Onboarding
 */
export const useUpdateOnboardingApiV1AgentBoardsBoardIdOnboardingPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateOnboardingApiV1AgentBoardsBoardIdOnboardingPost>
      >,
      TError,
      {
        boardId: string;
        data: BoardOnboardingAgentComplete | BoardOnboardingAgentQuestion;
      },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<
    ReturnType<typeof updateOnboardingApiV1AgentBoardsBoardIdOnboardingPost>
  >,
  TError,
  {
    boardId: string;
    data: BoardOnboardingAgentComplete | BoardOnboardingAgentQuestion;
  },
  TContext
> => {
  return useMutation(
    getUpdateOnboardingApiV1AgentBoardsBoardIdOnboardingPostMutationOptions(
      options,
    ),
    queryClient,
  );
};
/**
 * Send a direct coordination message to a specific board agent.

Use this when a lead sees stalled, idle, or misaligned work.
 * @summary Nudge an agent on a board
 */
export type agentLeadNudgeAgentResponse200 = {
  data: OkResponse;
  status: 200;
};

export type agentLeadNudgeAgentResponse403 = {
  data: LLMErrorResponse;
  status: 403;
};

export type agentLeadNudgeAgentResponse404 = {
  data: LLMErrorResponse;
  status: 404;
};

export type agentLeadNudgeAgentResponse422 = {
  data: LLMErrorResponse;
  status: 422;
};

export type agentLeadNudgeAgentResponse502 = {
  data: LLMErrorResponse;
  status: 502;
};

export type agentLeadNudgeAgentResponseSuccess =
  agentLeadNudgeAgentResponse200 & {
    headers: Headers;
  };
export type agentLeadNudgeAgentResponseError = (
  | agentLeadNudgeAgentResponse403
  | agentLeadNudgeAgentResponse404
  | agentLeadNudgeAgentResponse422
  | agentLeadNudgeAgentResponse502
) & {
  headers: Headers;
};

export type agentLeadNudgeAgentResponse =
  | agentLeadNudgeAgentResponseSuccess
  | agentLeadNudgeAgentResponseError;

export const getAgentLeadNudgeAgentUrl = (boardId: string, agentId: string) => {
  return `/api/v1/agent/boards/${boardId}/agents/${agentId}/nudge`;
};

export const agentLeadNudgeAgent = async (
  boardId: string,
  agentId: string,
  agentNudge: AgentNudge,
  options?: RequestInit,
): Promise<agentLeadNudgeAgentResponse> => {
  return customFetch<agentLeadNudgeAgentResponse>(
    getAgentLeadNudgeAgentUrl(boardId, agentId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(agentNudge),
    },
  );
};

export const getAgentLeadNudgeAgentMutationOptions = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentLeadNudgeAgent>>,
    TError,
    { boardId: string; agentId: string; data: AgentNudge },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentLeadNudgeAgent>>,
  TError,
  { boardId: string; agentId: string; data: AgentNudge },
  TContext
> => {
  const mutationKey = ["agentLeadNudgeAgent"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentLeadNudgeAgent>>,
    { boardId: string; agentId: string; data: AgentNudge }
  > = (props) => {
    const { boardId, agentId, data } = props ?? {};

    return agentLeadNudgeAgent(boardId, agentId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AgentLeadNudgeAgentMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentLeadNudgeAgent>>
>;
export type AgentLeadNudgeAgentMutationBody = AgentNudge;
export type AgentLeadNudgeAgentMutationError = LLMErrorResponse;

/**
 * @summary Nudge an agent on a board
 */
export const useAgentLeadNudgeAgent = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentLeadNudgeAgent>>,
      TError,
      { boardId: string; agentId: string; data: AgentNudge },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof agentLeadNudgeAgent>>,
  TError,
  { boardId: string; agentId: string; data: AgentNudge },
  TContext
> => {
  return useMutation(
    getAgentLeadNudgeAgentMutationOptions(options),
    queryClient,
  );
};
/**
 * Record liveness for the authenticated agent.

Use this when the agent heartbeat loop checks in.
 * @summary Upsert agent heartbeat
 */
export type agentHeartbeatApiV1AgentHeartbeatPostResponse200 = {
  data: AgentRead;
  status: 200;
};

export type agentHeartbeatApiV1AgentHeartbeatPostResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type agentHeartbeatApiV1AgentHeartbeatPostResponseSuccess =
  agentHeartbeatApiV1AgentHeartbeatPostResponse200 & {
    headers: Headers;
  };
export type agentHeartbeatApiV1AgentHeartbeatPostResponseError =
  agentHeartbeatApiV1AgentHeartbeatPostResponse422 & {
    headers: Headers;
  };

export type agentHeartbeatApiV1AgentHeartbeatPostResponse =
  | agentHeartbeatApiV1AgentHeartbeatPostResponseSuccess
  | agentHeartbeatApiV1AgentHeartbeatPostResponseError;

export const getAgentHeartbeatApiV1AgentHeartbeatPostUrl = () => {
  return `/api/v1/agent/heartbeat`;
};

export const agentHeartbeatApiV1AgentHeartbeatPost = async (
  options?: RequestInit,
): Promise<agentHeartbeatApiV1AgentHeartbeatPostResponse> => {
  return customFetch<agentHeartbeatApiV1AgentHeartbeatPostResponse>(
    getAgentHeartbeatApiV1AgentHeartbeatPostUrl(),
    {
      ...options,
      method: "POST",
    },
  );
};

export const getAgentHeartbeatApiV1AgentHeartbeatPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentHeartbeatApiV1AgentHeartbeatPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentHeartbeatApiV1AgentHeartbeatPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["agentHeartbeatApiV1AgentHeartbeatPost"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentHeartbeatApiV1AgentHeartbeatPost>>,
    void
  > = () => {
    return agentHeartbeatApiV1AgentHeartbeatPost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AgentHeartbeatApiV1AgentHeartbeatPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentHeartbeatApiV1AgentHeartbeatPost>>
>;

export type AgentHeartbeatApiV1AgentHeartbeatPostMutationError =
  HTTPValidationError;

/**
 * @summary Upsert agent heartbeat
 */
export const useAgentHeartbeatApiV1AgentHeartbeatPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentHeartbeatApiV1AgentHeartbeatPost>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof agentHeartbeatApiV1AgentHeartbeatPost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getAgentHeartbeatApiV1AgentHeartbeatPostMutationOptions(options),
    queryClient,
  );
};
/**
 * Fetch an agent's SOUL.md content.

Allowed for board lead, or for an agent reading its own SOUL.
 * @summary Get Agent Soul
 */
export type getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponse200 =
  {
    data: string;
    status: 200;
  };

export type getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponse422 =
  {
    data: HTTPValidationError;
    status: 422;
  };

export type getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponseSuccess =
  getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponse200 & {
    headers: Headers;
  };
export type getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponseError =
  getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponse422 & {
    headers: Headers;
  };

export type getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponse =
  | getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponseSuccess
  | getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponseError;

export const getGetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetUrl = (
  boardId: string,
  agentId: string,
) => {
  return `/api/v1/agent/boards/${boardId}/agents/${agentId}/soul`;
};

export const getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet = async (
  boardId: string,
  agentId: string,
  options?: RequestInit,
): Promise<getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponse> => {
  return customFetch<getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetResponse>(
    getGetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetUrl(
      boardId,
      agentId,
    ),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetQueryKey =
  (boardId: string, agentId: string) => {
    return [`/api/v1/agent/boards/${boardId}/agents/${agentId}/soul`] as const;
  };

export const getGetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet>
    >,
    TError = HTTPValidationError,
  >(
    boardId: string,
    agentId: string,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
            >
          >,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customFetch>;
    },
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetQueryKey(
        boardId,
        agentId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
        >
      >
    > = ({ signal }) =>
      getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet(
        boardId,
        agentId,
        { signal, ...requestOptions },
      );

    return {
      queryKey,
      queryFn,
      enabled: !!(boardId && agentId),
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet>
    >
  >;
export type GetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetQueryError =
  HTTPValidationError;

export function useGetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet<
  TData = Awaited<
    ReturnType<typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  agentId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
            >
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet<
  TData = Awaited<
    ReturnType<typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  agentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
            >
          >
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet<
  TData = Awaited<
    ReturnType<typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  agentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Agent Soul
 */

export function useGetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet<
  TData = Awaited<
    ReturnType<typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet>
  >,
  TError = HTTPValidationError,
>(
  boardId: string,
  agentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGet
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetAgentSoulApiV1AgentBoardsBoardIdAgentsAgentIdSoulGetQueryOptions(
      boardId,
      agentId,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Write SOUL.md content for a board agent and persist it for reprovisioning.

Use this when role instructions or behavior guardrails need updates.
 * @summary Update an agent's SOUL template
 */
export type agentLeadUpdateAgentSoulResponse200 = {
  data: OkResponse;
  status: 200;
};

export type agentLeadUpdateAgentSoulResponse403 = {
  data: LLMErrorResponse;
  status: 403;
};

export type agentLeadUpdateAgentSoulResponse404 = {
  data: LLMErrorResponse;
  status: 404;
};

export type agentLeadUpdateAgentSoulResponse422 = {
  data: LLMErrorResponse;
  status: 422;
};

export type agentLeadUpdateAgentSoulResponse502 = {
  data: LLMErrorResponse;
  status: 502;
};

export type agentLeadUpdateAgentSoulResponseSuccess =
  agentLeadUpdateAgentSoulResponse200 & {
    headers: Headers;
  };
export type agentLeadUpdateAgentSoulResponseError = (
  | agentLeadUpdateAgentSoulResponse403
  | agentLeadUpdateAgentSoulResponse404
  | agentLeadUpdateAgentSoulResponse422
  | agentLeadUpdateAgentSoulResponse502
) & {
  headers: Headers;
};

export type agentLeadUpdateAgentSoulResponse =
  | agentLeadUpdateAgentSoulResponseSuccess
  | agentLeadUpdateAgentSoulResponseError;

export const getAgentLeadUpdateAgentSoulUrl = (
  boardId: string,
  agentId: string,
) => {
  return `/api/v1/agent/boards/${boardId}/agents/${agentId}/soul`;
};

export const agentLeadUpdateAgentSoul = async (
  boardId: string,
  agentId: string,
  soulUpdateRequest: SoulUpdateRequest,
  options?: RequestInit,
): Promise<agentLeadUpdateAgentSoulResponse> => {
  return customFetch<agentLeadUpdateAgentSoulResponse>(
    getAgentLeadUpdateAgentSoulUrl(boardId, agentId),
    {
      ...options,
      method: "PUT",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(soulUpdateRequest),
    },
  );
};

export const getAgentLeadUpdateAgentSoulMutationOptions = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentLeadUpdateAgentSoul>>,
    TError,
    { boardId: string; agentId: string; data: SoulUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentLeadUpdateAgentSoul>>,
  TError,
  { boardId: string; agentId: string; data: SoulUpdateRequest },
  TContext
> => {
  const mutationKey = ["agentLeadUpdateAgentSoul"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentLeadUpdateAgentSoul>>,
    { boardId: string; agentId: string; data: SoulUpdateRequest }
  > = (props) => {
    const { boardId, agentId, data } = props ?? {};

    return agentLeadUpdateAgentSoul(boardId, agentId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AgentLeadUpdateAgentSoulMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentLeadUpdateAgentSoul>>
>;
export type AgentLeadUpdateAgentSoulMutationBody = SoulUpdateRequest;
export type AgentLeadUpdateAgentSoulMutationError = LLMErrorResponse;

/**
 * @summary Update an agent's SOUL template
 */
export const useAgentLeadUpdateAgentSoul = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentLeadUpdateAgentSoul>>,
      TError,
      { boardId: string; agentId: string; data: SoulUpdateRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof agentLeadUpdateAgentSoul>>,
  TError,
  { boardId: string; agentId: string; data: SoulUpdateRequest },
  TContext
> => {
  return useMutation(
    getAgentLeadUpdateAgentSoulMutationOptions(options),
    queryClient,
  );
};
/**
 * Permanently remove a board agent and tear down associated lifecycle state.

Use sparingly; prefer reassignment for continuity-sensitive teams.
 * @summary Delete a board agent as lead
 */
export type agentLeadDeleteBoardAgentResponse200 = {
  data: OkResponse;
  status: 200;
};

export type agentLeadDeleteBoardAgentResponse403 = {
  data: LLMErrorResponse;
  status: 403;
};

export type agentLeadDeleteBoardAgentResponse404 = {
  data: LLMErrorResponse;
  status: 404;
};

export type agentLeadDeleteBoardAgentResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type agentLeadDeleteBoardAgentResponseSuccess =
  agentLeadDeleteBoardAgentResponse200 & {
    headers: Headers;
  };
export type agentLeadDeleteBoardAgentResponseError = (
  | agentLeadDeleteBoardAgentResponse403
  | agentLeadDeleteBoardAgentResponse404
  | agentLeadDeleteBoardAgentResponse422
) & {
  headers: Headers;
};

export type agentLeadDeleteBoardAgentResponse =
  | agentLeadDeleteBoardAgentResponseSuccess
  | agentLeadDeleteBoardAgentResponseError;

export const getAgentLeadDeleteBoardAgentUrl = (
  boardId: string,
  agentId: string,
) => {
  return `/api/v1/agent/boards/${boardId}/agents/${agentId}`;
};

export const agentLeadDeleteBoardAgent = async (
  boardId: string,
  agentId: string,
  options?: RequestInit,
): Promise<agentLeadDeleteBoardAgentResponse> => {
  return customFetch<agentLeadDeleteBoardAgentResponse>(
    getAgentLeadDeleteBoardAgentUrl(boardId, agentId),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getAgentLeadDeleteBoardAgentMutationOptions = <
  TError = LLMErrorResponse | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentLeadDeleteBoardAgent>>,
    TError,
    { boardId: string; agentId: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentLeadDeleteBoardAgent>>,
  TError,
  { boardId: string; agentId: string },
  TContext
> => {
  const mutationKey = ["agentLeadDeleteBoardAgent"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentLeadDeleteBoardAgent>>,
    { boardId: string; agentId: string }
  > = (props) => {
    const { boardId, agentId } = props ?? {};

    return agentLeadDeleteBoardAgent(boardId, agentId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AgentLeadDeleteBoardAgentMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentLeadDeleteBoardAgent>>
>;

export type AgentLeadDeleteBoardAgentMutationError =
  | LLMErrorResponse
  | HTTPValidationError;

/**
 * @summary Delete a board agent as lead
 */
export const useAgentLeadDeleteBoardAgent = <
  TError = LLMErrorResponse | HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentLeadDeleteBoardAgent>>,
      TError,
      { boardId: string; agentId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof agentLeadDeleteBoardAgent>>,
  TError,
  { boardId: string; agentId: string },
  TContext
> => {
  return useMutation(
    getAgentLeadDeleteBoardAgentMutationOptions(options),
    queryClient,
  );
};
/**
 * Escalate a high-impact decision or ambiguity through the gateway-main interaction channel.

Use when lead-level context needs human confirmation or consent.
 * @summary Ask the human via gateway-main
 */
export type agentLeadAskUserViaGatewayMainResponse200 = {
  data: GatewayMainAskUserResponse;
  status: 200;
};

export type agentLeadAskUserViaGatewayMainResponse403 = {
  data: LLMErrorResponse;
  status: 403;
};

export type agentLeadAskUserViaGatewayMainResponse404 = {
  data: LLMErrorResponse;
  status: 404;
};

export type agentLeadAskUserViaGatewayMainResponse422 = {
  data: HTTPValidationError;
  status: 422;
};

export type agentLeadAskUserViaGatewayMainResponse502 = {
  data: LLMErrorResponse;
  status: 502;
};

export type agentLeadAskUserViaGatewayMainResponseSuccess =
  agentLeadAskUserViaGatewayMainResponse200 & {
    headers: Headers;
  };
export type agentLeadAskUserViaGatewayMainResponseError = (
  | agentLeadAskUserViaGatewayMainResponse403
  | agentLeadAskUserViaGatewayMainResponse404
  | agentLeadAskUserViaGatewayMainResponse422
  | agentLeadAskUserViaGatewayMainResponse502
) & {
  headers: Headers;
};

export type agentLeadAskUserViaGatewayMainResponse =
  | agentLeadAskUserViaGatewayMainResponseSuccess
  | agentLeadAskUserViaGatewayMainResponseError;

export const getAgentLeadAskUserViaGatewayMainUrl = (boardId: string) => {
  return `/api/v1/agent/boards/${boardId}/gateway/main/ask-user`;
};

export const agentLeadAskUserViaGatewayMain = async (
  boardId: string,
  gatewayMainAskUserRequest: GatewayMainAskUserRequest,
  options?: RequestInit,
): Promise<agentLeadAskUserViaGatewayMainResponse> => {
  return customFetch<agentLeadAskUserViaGatewayMainResponse>(
    getAgentLeadAskUserViaGatewayMainUrl(boardId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(gatewayMainAskUserRequest),
    },
  );
};

export const getAgentLeadAskUserViaGatewayMainMutationOptions = <
  TError = LLMErrorResponse | HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentLeadAskUserViaGatewayMain>>,
    TError,
    { boardId: string; data: GatewayMainAskUserRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentLeadAskUserViaGatewayMain>>,
  TError,
  { boardId: string; data: GatewayMainAskUserRequest },
  TContext
> => {
  const mutationKey = ["agentLeadAskUserViaGatewayMain"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentLeadAskUserViaGatewayMain>>,
    { boardId: string; data: GatewayMainAskUserRequest }
  > = (props) => {
    const { boardId, data } = props ?? {};

    return agentLeadAskUserViaGatewayMain(boardId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AgentLeadAskUserViaGatewayMainMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentLeadAskUserViaGatewayMain>>
>;
export type AgentLeadAskUserViaGatewayMainMutationBody =
  GatewayMainAskUserRequest;
export type AgentLeadAskUserViaGatewayMainMutationError =
  | LLMErrorResponse
  | HTTPValidationError;

/**
 * @summary Ask the human via gateway-main
 */
export const useAgentLeadAskUserViaGatewayMain = <
  TError = LLMErrorResponse | HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentLeadAskUserViaGatewayMain>>,
      TError,
      { boardId: string; data: GatewayMainAskUserRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof agentLeadAskUserViaGatewayMain>>,
  TError,
  { boardId: string; data: GatewayMainAskUserRequest },
  TContext
> => {
  return useMutation(
    getAgentLeadAskUserViaGatewayMainMutationOptions(options),
    queryClient,
  );
};
/**
 * Route a direct lead handoff or question from an agent to the board lead.

Use when a lead requires explicit, board-scoped routing.
 * @summary Message board lead via gateway-main
 */
export type agentMainMessageBoardLeadResponse200 = {
  data: GatewayLeadMessageResponse;
  status: 200;
};

export type agentMainMessageBoardLeadResponse403 = {
  data: LLMErrorResponse;
  status: 403;
};

export type agentMainMessageBoardLeadResponse404 = {
  data: LLMErrorResponse;
  status: 404;
};

export type agentMainMessageBoardLeadResponse422 = {
  data: LLMErrorResponse;
  status: 422;
};

export type agentMainMessageBoardLeadResponse502 = {
  data: LLMErrorResponse;
  status: 502;
};

export type agentMainMessageBoardLeadResponseSuccess =
  agentMainMessageBoardLeadResponse200 & {
    headers: Headers;
  };
export type agentMainMessageBoardLeadResponseError = (
  | agentMainMessageBoardLeadResponse403
  | agentMainMessageBoardLeadResponse404
  | agentMainMessageBoardLeadResponse422
  | agentMainMessageBoardLeadResponse502
) & {
  headers: Headers;
};

export type agentMainMessageBoardLeadResponse =
  | agentMainMessageBoardLeadResponseSuccess
  | agentMainMessageBoardLeadResponseError;

export const getAgentMainMessageBoardLeadUrl = (boardId: string) => {
  return `/api/v1/agent/gateway/boards/${boardId}/lead/message`;
};

export const agentMainMessageBoardLead = async (
  boardId: string,
  gatewayLeadMessageRequest: GatewayLeadMessageRequest,
  options?: RequestInit,
): Promise<agentMainMessageBoardLeadResponse> => {
  return customFetch<agentMainMessageBoardLeadResponse>(
    getAgentMainMessageBoardLeadUrl(boardId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(gatewayLeadMessageRequest),
    },
  );
};

export const getAgentMainMessageBoardLeadMutationOptions = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentMainMessageBoardLead>>,
    TError,
    { boardId: string; data: GatewayLeadMessageRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentMainMessageBoardLead>>,
  TError,
  { boardId: string; data: GatewayLeadMessageRequest },
  TContext
> => {
  const mutationKey = ["agentMainMessageBoardLead"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentMainMessageBoardLead>>,
    { boardId: string; data: GatewayLeadMessageRequest }
  > = (props) => {
    const { boardId, data } = props ?? {};

    return agentMainMessageBoardLead(boardId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AgentMainMessageBoardLeadMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentMainMessageBoardLead>>
>;
export type AgentMainMessageBoardLeadMutationBody = GatewayLeadMessageRequest;
export type AgentMainMessageBoardLeadMutationError = LLMErrorResponse;

/**
 * @summary Message board lead via gateway-main
 */
export const useAgentMainMessageBoardLead = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentMainMessageBoardLead>>,
      TError,
      { boardId: string; data: GatewayLeadMessageRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof agentMainMessageBoardLead>>,
  TError,
  { boardId: string; data: GatewayLeadMessageRequest },
  TContext
> => {
  return useMutation(
    getAgentMainMessageBoardLeadMutationOptions(options),
    queryClient,
  );
};
/**
 * Send a shared coordination request to multiple board leads.

Use for urgent cross-board or multi-lead fan-out patterns.
 * @summary Broadcast a message to board leads via gateway-main
 */
export type agentMainBroadcastLeadMessageResponse200 = {
  data: GatewayLeadBroadcastResponse;
  status: 200;
};

export type agentMainBroadcastLeadMessageResponse403 = {
  data: LLMErrorResponse;
  status: 403;
};

export type agentMainBroadcastLeadMessageResponse404 = {
  data: LLMErrorResponse;
  status: 404;
};

export type agentMainBroadcastLeadMessageResponse422 = {
  data: LLMErrorResponse;
  status: 422;
};

export type agentMainBroadcastLeadMessageResponse502 = {
  data: LLMErrorResponse;
  status: 502;
};

export type agentMainBroadcastLeadMessageResponseSuccess =
  agentMainBroadcastLeadMessageResponse200 & {
    headers: Headers;
  };
export type agentMainBroadcastLeadMessageResponseError = (
  | agentMainBroadcastLeadMessageResponse403
  | agentMainBroadcastLeadMessageResponse404
  | agentMainBroadcastLeadMessageResponse422
  | agentMainBroadcastLeadMessageResponse502
) & {
  headers: Headers;
};

export type agentMainBroadcastLeadMessageResponse =
  | agentMainBroadcastLeadMessageResponseSuccess
  | agentMainBroadcastLeadMessageResponseError;

export const getAgentMainBroadcastLeadMessageUrl = () => {
  return `/api/v1/agent/gateway/leads/broadcast`;
};

export const agentMainBroadcastLeadMessage = async (
  gatewayLeadBroadcastRequest: GatewayLeadBroadcastRequest,
  options?: RequestInit,
): Promise<agentMainBroadcastLeadMessageResponse> => {
  return customFetch<agentMainBroadcastLeadMessageResponse>(
    getAgentMainBroadcastLeadMessageUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(gatewayLeadBroadcastRequest),
    },
  );
};

export const getAgentMainBroadcastLeadMessageMutationOptions = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof agentMainBroadcastLeadMessage>>,
    TError,
    { data: GatewayLeadBroadcastRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof agentMainBroadcastLeadMessage>>,
  TError,
  { data: GatewayLeadBroadcastRequest },
  TContext
> => {
  const mutationKey = ["agentMainBroadcastLeadMessage"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof agentMainBroadcastLeadMessage>>,
    { data: GatewayLeadBroadcastRequest }
  > = (props) => {
    const { data } = props ?? {};

    return agentMainBroadcastLeadMessage(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AgentMainBroadcastLeadMessageMutationResult = NonNullable<
  Awaited<ReturnType<typeof agentMainBroadcastLeadMessage>>
>;
export type AgentMainBroadcastLeadMessageMutationBody =
  GatewayLeadBroadcastRequest;
export type AgentMainBroadcastLeadMessageMutationError = LLMErrorResponse;

/**
 * @summary Broadcast a message to board leads via gateway-main
 */
export const useAgentMainBroadcastLeadMessage = <
  TError = LLMErrorResponse,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof agentMainBroadcastLeadMessage>>,
      TError,
      { data: GatewayLeadBroadcastRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof agentMainBroadcastLeadMessage>>,
  TError,
  { data: GatewayLeadBroadcastRequest },
  TContext
> => {
  return useMutation(
    getAgentMainBroadcastLeadMessageMutationOptions(options),
    queryClient,
  );
};
